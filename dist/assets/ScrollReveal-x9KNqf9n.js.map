{"version":3,"file":"ScrollReveal-x9KNqf9n.js","sources":["../../node_modules/framer-motion/dist/es/animation/hooks/animation-controls.mjs","../../node_modules/framer-motion/dist/es/animation/hooks/use-animation.mjs","../../node_modules/framer-motion/dist/es/render/dom/viewport/index.mjs","../../node_modules/framer-motion/dist/es/utils/use-in-view.mjs","../../src/components/ScrollReveal.tsx"],"sourcesContent":["import { invariant } from 'motion-utils';\nimport { setTarget } from '../../render/utils/setters.mjs';\nimport { animateVisualElement } from '../interfaces/visual-element.mjs';\n\nfunction stopAnimation(visualElement) {\n    visualElement.values.forEach((value) => value.stop());\n}\nfunction setVariants(visualElement, variantLabels) {\n    const reversedLabels = [...variantLabels].reverse();\n    reversedLabels.forEach((key) => {\n        const variant = visualElement.getVariant(key);\n        variant && setTarget(visualElement, variant);\n        if (visualElement.variantChildren) {\n            visualElement.variantChildren.forEach((child) => {\n                setVariants(child, variantLabels);\n            });\n        }\n    });\n}\nfunction setValues(visualElement, definition) {\n    if (Array.isArray(definition)) {\n        return setVariants(visualElement, definition);\n    }\n    else if (typeof definition === \"string\") {\n        return setVariants(visualElement, [definition]);\n    }\n    else {\n        setTarget(visualElement, definition);\n    }\n}\n/**\n * @public\n */\nfunction animationControls() {\n    /**\n     * Track whether the host component has mounted.\n     */\n    let hasMounted = false;\n    /**\n     * A collection of linked component animation controls.\n     */\n    const subscribers = new Set();\n    const controls = {\n        subscribe(visualElement) {\n            subscribers.add(visualElement);\n            return () => void subscribers.delete(visualElement);\n        },\n        start(definition, transitionOverride) {\n            invariant(hasMounted, \"controls.start() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            const animations = [];\n            subscribers.forEach((visualElement) => {\n                animations.push(animateVisualElement(visualElement, definition, {\n                    transitionOverride,\n                }));\n            });\n            return Promise.all(animations);\n        },\n        set(definition) {\n            invariant(hasMounted, \"controls.set() should only be called after a component has mounted. Consider calling within a useEffect hook.\");\n            return subscribers.forEach((visualElement) => {\n                setValues(visualElement, definition);\n            });\n        },\n        stop() {\n            subscribers.forEach((visualElement) => {\n                stopAnimation(visualElement);\n            });\n        },\n        mount() {\n            hasMounted = true;\n            return () => {\n                hasMounted = false;\n                controls.stop();\n            };\n        },\n    };\n    return controls;\n}\n\nexport { animationControls, setValues };\n","import { animationControls } from './animation-controls.mjs';\nimport { useConstant } from '../../utils/use-constant.mjs';\nimport { useIsomorphicLayoutEffect } from '../../utils/use-isomorphic-effect.mjs';\n\n/**\n * Creates `AnimationControls`, which can be used to manually start, stop\n * and sequence animations on one or more components.\n *\n * The returned `AnimationControls` should be passed to the `animate` property\n * of the components you want to animate.\n *\n * These components can then be animated with the `start` method.\n *\n * ```jsx\n * import * as React from 'react'\n * import { motion, useAnimation } from 'framer-motion'\n *\n * export function MyComponent(props) {\n *    const controls = useAnimation()\n *\n *    controls.start({\n *        x: 100,\n *        transition: { duration: 0.5 },\n *    })\n *\n *    return <motion.div animate={controls} />\n * }\n * ```\n *\n * @returns Animation controller with `start` and `stop` methods\n *\n * @public\n */\nfunction useAnimationControls() {\n    const controls = useConstant(animationControls);\n    useIsomorphicLayoutEffect(controls.mount, []);\n    return controls;\n}\nconst useAnimation = useAnimationControls;\n\nexport { useAnimation, useAnimationControls };\n","import { resolveElements } from 'motion-dom';\n\nconst thresholds = {\n    some: 0,\n    all: 1,\n};\nfunction inView(elementOrSelector, onStart, { root, margin: rootMargin, amount = \"some\" } = {}) {\n    const elements = resolveElements(elementOrSelector);\n    const activeIntersections = new WeakMap();\n    const onIntersectionChange = (entries) => {\n        entries.forEach((entry) => {\n            const onEnd = activeIntersections.get(entry.target);\n            /**\n             * If there's no change to the intersection, we don't need to\n             * do anything here.\n             */\n            if (entry.isIntersecting === Boolean(onEnd))\n                return;\n            if (entry.isIntersecting) {\n                const newOnEnd = onStart(entry);\n                if (typeof newOnEnd === \"function\") {\n                    activeIntersections.set(entry.target, newOnEnd);\n                }\n                else {\n                    observer.unobserve(entry.target);\n                }\n            }\n            else if (typeof onEnd === \"function\") {\n                onEnd(entry);\n                activeIntersections.delete(entry.target);\n            }\n        });\n    };\n    const observer = new IntersectionObserver(onIntersectionChange, {\n        root,\n        rootMargin,\n        threshold: typeof amount === \"number\" ? amount : thresholds[amount],\n    });\n    elements.forEach((element) => observer.observe(element));\n    return () => observer.disconnect();\n}\n\nexport { inView };\n","import { useState, useEffect } from 'react';\nimport { inView } from '../render/dom/viewport/index.mjs';\n\nfunction useInView(ref, { root, margin, amount, once = false } = {}) {\n    const [isInView, setInView] = useState(false);\n    useEffect(() => {\n        if (!ref.current || (once && isInView))\n            return;\n        const onEnter = () => {\n            setInView(true);\n            return once ? undefined : () => setInView(false);\n        };\n        const options = {\n            root: (root && root.current) || undefined,\n            margin,\n            amount,\n        };\n        return inView(ref.current, onEnter, options);\n    }, [root, ref, margin, once, amount]);\n    return isInView;\n}\n\nexport { useInView };\n","import { useEffect, useRef, ReactNode } from \"react\";\r\nimport { motion, useInView, useAnimation } from \"framer-motion\";\r\n\r\ninterface ScrollRevealProps {\r\n  children: ReactNode;\r\n  delay?: number;\r\n  direction?: \"up\" | \"down\" | \"left\" | \"right\";\r\n  className?: string;\r\n}\r\n\r\nexport const ScrollReveal = ({ \r\n  children, \r\n  delay = 0, \r\n  direction = \"up\",\r\n  className = \"\"\r\n}: ScrollRevealProps) => {\r\n  const ref = useRef(null);\r\n  const isInView = useInView(ref, { once: true, amount: 0.1 });\r\n  const controls = useAnimation();\r\n\r\n  useEffect(() => {\r\n    if (isInView) {\r\n      controls.start(\"visible\");\r\n    }\r\n  }, [isInView, controls]);\r\n\r\n  const directions = {\r\n    up: { y: 50 },\r\n    down: { y: -50 },\r\n    left: { x: 50 },\r\n    right: { x: -50 }\r\n  };\r\n\r\n  return (\r\n    <motion.div\r\n      ref={ref}\r\n      initial=\"hidden\"\r\n      animate={controls}\r\n      variants={{\r\n        hidden: { \r\n          opacity: 0,\r\n          ...directions[direction]\r\n        },\r\n        visible: {\r\n          opacity: 1,\r\n          x: 0,\r\n          y: 0,\r\n          transition: {\r\n            duration: 0.6,\r\n            delay,\r\n            ease: \"easeOut\"\r\n          }\r\n        }\r\n      }}\r\n      className={className}\r\n    >\r\n      {children}\r\n    </motion.div>\r\n  );\r\n};\r\n"],"names":["stopAnimation","visualElement","value","setVariants","variantLabels","key","variant","setTarget","child","setValues","definition","animationControls","subscribers","controls","transitionOverride","animations","animateVisualElement","useAnimationControls","useConstant","useIsomorphicLayoutEffect","useAnimation","thresholds","inView","elementOrSelector","onStart","root","rootMargin","amount","elements","resolveElements","activeIntersections","onIntersectionChange","entries","entry","onEnd","newOnEnd","observer","element","useInView","ref","margin","once","isInView","setInView","useState","useEffect","onEnter","options","ScrollReveal","children","delay","direction","className","useRef","directions","jsx","motion"],"mappings":"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","x_google_ignoreList":[0,1,2,3]}