{"version":3,"file":"EstimateImage-Cqe3rfd3.js","sources":["../../src/utils/storageUtils.ts","../../src/components/EstimateImage.tsx"],"sourcesContent":["import { supabase } from \"@/integrations/supabase/client\";\r\n\r\n/**\r\n * Generate a signed URL for a private storage file\r\n * @param bucket - The storage bucket name\r\n * @param path - The file path within the bucket\r\n * @param expiresIn - URL expiration time in seconds (default: 1 hour)\r\n * @returns The signed URL or null if generation fails\r\n */\r\nexport const getSignedUrl = async (\r\n  bucket: string,\r\n  path: string,\r\n  expiresIn: number = 3600\r\n): Promise<string | null> => {\r\n  try {\r\n    const { data, error } = await supabase.storage\r\n      .from(bucket)\r\n      .createSignedUrl(path, expiresIn);\r\n\r\n    if (error) {\r\n      console.error('Error generating signed URL:', error);\r\n      return null;\r\n    }\r\n\r\n    return data.signedUrl;\r\n  } catch (error) {\r\n    console.error('Failed to generate signed URL:', error);\r\n    return null;\r\n  }\r\n};\r\n\r\n/**\r\n * Generate signed URLs for multiple files\r\n * @param bucket - The storage bucket name\r\n * @param paths - Array of file paths within the bucket\r\n * @param expiresIn - URL expiration time in seconds (default: 1 hour)\r\n * @returns Array of signed URLs in the same order as paths\r\n */\r\nexport const getSignedUrls = async (\r\n  bucket: string,\r\n  paths: string[],\r\n  expiresIn: number = 3600\r\n): Promise<(string | null)[]> => {\r\n  return Promise.all(\r\n    paths.map(path => getSignedUrl(bucket, path, expiresIn))\r\n  );\r\n};\r\n\r\n/**\r\n * Extract file path from a full storage URL\r\n * @param url - The full storage URL\r\n * @param bucket - The bucket name to extract path from\r\n * @returns The file path within the bucket\r\n */\r\nexport const extractPathFromUrl = (url: string, bucket: string): string => {\r\n  try {\r\n    const urlObj = new URL(url);\r\n    const pathParts = urlObj.pathname.split(`/${bucket}/`);\r\n    return pathParts.length > 1 ? pathParts[1] : url;\r\n  } catch {\r\n    // If URL parsing fails, assume it's already a path\r\n    return url;\r\n  }\r\n};\r\n\r\n/**\r\n * Get a signed URL from a manufacturing-estimates storage URL\r\n * Converts public URLs or paths to signed URLs for private access\r\n * @param imageUrl - The image URL or path\r\n * @param expiresIn - URL expiration time in seconds (default: 1 hour)\r\n * @returns The signed URL or the original URL if conversion fails\r\n */\r\nexport const getEstimateImageSignedUrl = async (\r\n  imageUrl: string,\r\n  expiresIn: number = 3600\r\n): Promise<string> => {\r\n  if (!imageUrl) return imageUrl;\r\n  \r\n  const path = extractPathFromUrl(imageUrl, 'manufacturing-estimates');\r\n  const signedUrl = await getSignedUrl('manufacturing-estimates', path, expiresIn);\r\n  \r\n  return signedUrl || imageUrl;\r\n};\r\n\r\n/**\r\n * Upload file to manufacturing-estimates bucket with proper user folder structure\r\n * @param file - The file to upload\r\n * @param userId - The user's ID for folder organization\r\n * @returns The file path in storage (not signed URL)\r\n */\r\nexport const uploadEstimateImage = async (\r\n  file: File,\r\n  userId: string\r\n): Promise<string> => {\r\n  const fileExt = file.name.split('.').pop();\r\n  const timestamp = Date.now();\r\n  const randomString = Math.random().toString(36).substring(7);\r\n  const filePath = `${userId}/${timestamp}_${randomString}.${fileExt}`;\r\n\r\n  const { data, error } = await supabase.storage\r\n    .from('manufacturing-estimates')\r\n    .upload(filePath, file, {\r\n      cacheControl: '3600',\r\n      upsert: false\r\n    });\r\n\r\n  if (error) {\r\n    console.error('Upload error:', error);\r\n    throw new Error(`Failed to upload image: ${error.message}`);\r\n  }\r\n\r\n  return data.path;\r\n};\r\n","import { useState, useEffect } from \"react\";\r\nimport { getEstimateImageSignedUrl } from \"@/utils/storageUtils\";\r\nimport { Loader2 } from \"lucide-react\";\r\n\r\ninterface EstimateImageProps {\r\n  src: string;\r\n  alt: string;\r\n  className?: string;\r\n}\r\n\r\n/**\r\n * Component for displaying images from the manufacturing-estimates bucket\r\n * Automatically converts storage paths to signed URLs for secure access\r\n */\r\nexport const EstimateImage = ({ src, alt, className = \"\" }: EstimateImageProps) => {\r\n  const [signedUrl, setSignedUrl] = useState<string>(\"\");\r\n  const [loading, setLoading] = useState(true);\r\n  const [error, setError] = useState(false);\r\n\r\n  useEffect(() => {\r\n    const loadSignedUrl = async () => {\r\n      if (!src) {\r\n        setLoading(false);\r\n        return;\r\n      }\r\n\r\n      try {\r\n        setLoading(true);\r\n        setError(false);\r\n        const url = await getEstimateImageSignedUrl(src);\r\n        setSignedUrl(url);\r\n      } catch (err) {\r\n        console.error(\"Failed to load image:\", err);\r\n        setError(true);\r\n      } finally {\r\n        setLoading(false);\r\n      }\r\n    };\r\n\r\n    loadSignedUrl();\r\n  }, [src]);\r\n\r\n  if (!src) {\r\n    return null;\r\n  }\r\n\r\n  if (loading) {\r\n    return (\r\n      <div className={`flex items-center justify-center bg-muted ${className}`}>\r\n        <Loader2 className=\"h-6 w-6 animate-spin text-muted-foreground\" />\r\n      </div>\r\n    );\r\n  }\r\n\r\n  if (error || !signedUrl) {\r\n    return (\r\n      <div className={`flex items-center justify-center bg-muted ${className}`}>\r\n        <span className=\"text-sm text-muted-foreground\">Failed to load image</span>\r\n      </div>\r\n    );\r\n  }\r\n\r\n  return (\r\n    <img\r\n      src={signedUrl}\r\n      alt={alt}\r\n      className={className}\r\n      onError={() => setError(true)}\r\n    />\r\n  );\r\n};\r\n"],"names":["getSignedUrl","bucket","path","expiresIn","data","error","supabase","extractPathFromUrl","url","pathParts","getEstimateImageSignedUrl","imageUrl","EstimateImage","src","alt","className","signedUrl","setSignedUrl","useState","loading","setLoading","setError","useEffect","err","jsx","Loader2"],"mappings":"mLASO,MAAMA,EAAe,MAC1BC,EACAC,EACAC,EAAoB,OACO,CAC3B,GAAI,CACF,KAAM,CAAE,KAAAC,EAAM,MAAAC,CAAA,EAAU,MAAMC,EAAS,QACpC,KAAKL,CAAM,EACX,gBAAgBC,EAAMC,CAAS,EAElC,OAAIE,GACF,QAAQ,MAAM,+BAAgCA,CAAK,EAC5C,MAGFD,EAAK,SACd,OAASC,EAAO,CACd,eAAQ,MAAM,iCAAkCA,CAAK,EAC9C,IACT,CACF,EAyBaE,EAAqB,CAACC,EAAaP,IAA2B,CACzE,GAAI,CAEF,MAAMQ,EADS,IAAI,IAAID,CAAG,EACD,SAAS,MAAM,IAAIP,CAAM,GAAG,EACrD,OAAOQ,EAAU,OAAS,EAAIA,EAAU,CAAC,EAAID,CAC/C,MAAQ,CAEN,OAAOA,CACT,CACF,EASaE,EAA4B,MACvCC,EACAR,EAAoB,OACA,CACpB,GAAI,CAACQ,EAAU,OAAOA,EAEtB,MAAMT,EAAOK,EAAmBI,EAAU,yBAAyB,EAGnE,OAFkB,MAAMX,EAAa,0BAA2BE,EAAMC,CAAS,GAE3DQ,CACtB,ECpEaC,EAAgB,CAAC,CAAE,IAAAC,EAAK,IAAAC,EAAK,UAAAC,EAAY,MAA6B,CACjF,KAAM,CAACC,EAAWC,CAAY,EAAIC,EAAAA,SAAiB,EAAE,EAC/C,CAACC,EAASC,CAAU,EAAIF,EAAAA,SAAS,EAAI,EACrC,CAACb,EAAOgB,CAAQ,EAAIH,EAAAA,SAAS,EAAK,EAyBxC,OAvBAI,EAAAA,UAAU,IAAM,EACQ,SAAY,CAChC,GAAI,CAACT,EAAK,CACRO,EAAW,EAAK,EAChB,MACF,CAEA,GAAI,CACFA,EAAW,EAAI,EACfC,EAAS,EAAK,EACd,MAAMb,EAAM,MAAME,EAA0BG,CAAG,EAC/CI,EAAaT,CAAG,CAClB,OAASe,EAAK,CACZ,QAAQ,MAAM,wBAAyBA,CAAG,EAC1CF,EAAS,EAAI,CACf,QAAA,CACED,EAAW,EAAK,CAClB,CACF,GAEA,CACF,EAAG,CAACP,CAAG,CAAC,EAEHA,EAIDM,EAEAK,EAAAA,IAAC,MAAA,CAAI,UAAW,6CAA6CT,CAAS,GACpE,SAAAS,EAAAA,IAACC,EAAA,CAAQ,UAAU,4CAAA,CAA6C,CAAA,CAClE,EAIApB,GAAS,CAACW,EAEVQ,EAAAA,IAAC,MAAA,CAAI,UAAW,6CAA6CT,CAAS,GACpE,SAAAS,EAAAA,IAAC,OAAA,CAAK,UAAU,gCAAgC,SAAA,sBAAA,CAAoB,EACtE,EAKFA,EAAAA,IAAC,MAAA,CACC,IAAKR,EACL,IAAAF,EACA,UAAAC,EACA,QAAS,IAAMM,EAAS,EAAI,CAAA,CAAA,EAxBvB,IA2BX"}